import os
import subprocess
import pandas as pd
from pypdf import PdfReader
from typing import TypedDict, Annotated
from langgraph.graph import StateGraph, END
from langchain_google_genai import ChatGoogleGenerativeAI

# Load environment variables
from dotenv import load_dotenv
load_dotenv()

# Define the State
class AgentState(TypedDict):
    target_bank: str      # The bank we're targeting, e.g., "icici"
    current_code: str     # The Python code generated by the LLM
    error_feedback: str   # Feedback from a failed test run
    attempts_left: int    # The number of self-fix attempts remaining 

# Initialize the LLM
llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash")

# Define the Nodes
def plan_and_generate(state: AgentState):
    """
    Reads sample files and generates a detailed, grounded prompt to create the parser.
    """
    print("---PLAN & GENERATE---")
    bank = state['target_bank']
    
    # Define paths
    pdf_path = f"data/{bank}/{bank} sample.pdf"
    csv_path = f"data/{bank}/result.csv"
    
    # Read the expected output schema and head from the CSV
    expected_df = pd.read_csv(csv_path)
    csv_head = expected_df.head().to_string()
    schema = expected_df.columns.tolist()

    # Read the text from the first page of the PDF
    try:
        reader = PdfReader(pdf_path)
        pdf_text_content = reader.pages[0].extract_text(extraction_mode="layout")
    except Exception as e:
        pdf_text_content = f"Could not read PDF content. Error: {e}"

    # Promt for llm
    prompt = f"""
    You are an expert Python programmer specializing in data extraction from messy PDFs.
    Your task is to write a Python script to parse a bank statement PDF and return a pandas DataFrame.

    **Goal**: Write a single Python function `parse(pdf_path: str) -> pd.DataFrame`.

    **Key Requirements**:
    1.  The function must accept a `pdf_path` string.
    2.  It must return a pandas DataFrame with the EXACT schema: `{schema}`.
    3.  The data types should be appropriate (dates as datetime objects, amounts as floats).
    4.  Crucially, where a transaction is either a debit OR a credit, the other column must be `NaN`, not `0.00`.

    **CONTEXT AND ANALYSIS**:

    To help you, I have extracted the text from the first page of the target PDF. Analyze this text to understand the table's structure, headers, and data format.

    **Sample PDF Text Content (from page 1 of `{pdf_path}`):**
    ```
    {pdf_text_content[:2000]} 
    ```

    I have also provided the head of the expected final DataFrame from the corresponding CSV file. Your parser's output MUST match this format and data exactly.

    **Expected Output DataFrame Head (from `{csv_path}`):**
    ```
    {csv_head}
    ```

    **Your Plan of Action**:
    -   Use the `camelot-py` library, as it is best for table extraction.
    -   Examine the PDF text to determine the best `camelot.read_pdf` parameters (e.g., `flavor`, `row_tol`).
    -   Identify the header row from the text.
    -   Write logic to map the raw PDF columns to the required schema: `{schema}`.
    -   Implement logic to clean the data, especially dates and numeric values. Remember to handle commas in numbers.
    -   Ensure your final DataFrame's column order and content match the provided example.

    Now, based on this detailed context, write the complete, raw Python code for the `parse` function. Do not include any explanations or markdown formatting.
    """

    response = llm.invoke(prompt)
    return {"current_code": response.content}

def execute_and_test(state: AgentState):
    """Saves the code and runs the test harness."""
    print("---EXECUTE & TEST---")
    bank = state['target_bank']
    code = state['current_code']

    # Cleaning the code string to remove markdown fences if they exist.
    if code.strip().startswith("```python"):
        code = code.strip()[len("```python"):].strip()
    if code.strip().endswith("```"):
        code = code.strip()[:-len("```")].strip()

    parser_dir = "custom_parsers"
    os.makedirs(parser_dir, exist_ok=True)
    
    with open(os.path.join(parser_dir, "__init__.py"), "w") as f:
        pass
    
    parser_path = os.path.join(parser_dir, f"{bank}_parser.py")
    with open(parser_path, "w") as f:
        f.write(code)

    result = subprocess.run(
        ["python", "run_parser_test.py", bank],
        capture_output=True,
        text=True,
    )

    if result.returncode == 0:
        print("Test script output:", result.stdout)
        return {"error_feedback": None}
    else:
        print("Test script error:", result.stdout + result.stderr)
        return {"error_feedback": result.stdout + result.stderr}

def refine_code(state: AgentState):
    """Based on feedback, asks the LLM to fix the code."""
    print("---REFINE CODE---")
    
    refinement_prompt = f"""
    The Python code you previously provided failed.

    **Previous Code:**
    ```python
    {state['current_code']}
    ```

    **Error/Feedback from the test run:**
    {state['error_feedback']}

    Please analyze the error and the code, and provide a corrected version.
    Again, only output the raw, corrected Python code without any extra text or explanations.
    """
    
    response = llm.invoke(refinement_prompt)
    return {"current_code": response.content, "attempts_left": state['attempts_left'] - 1}

def decide_next_step(state: AgentState):
    """Checks the test result to decide where to go next."""
    print("---DECIDE NEXT STEP---")
    if state["error_feedback"] is None:
        print("Code is correct. Finishing.")
        return "end"
    elif state["attempts_left"] > 0:
        print(f"Code has errors. Refining. Attempts left: {state['attempts_left']}")
        return "refine"
    else:
        print("Max attempts reached. Failing.")
        return "end"

workflow = StateGraph(AgentState)

workflow.add_node("planner", plan_and_generate)
workflow.add_node("executor", execute_and_test)
workflow.add_node("refiner", refine_code)

workflow.set_entry_point("planner")

workflow.add_edge("planner", "executor")
workflow.add_edge("refiner", "executor")

workflow.add_conditional_edges(
    "executor",
    decide_next_step,
    {
        "refine": "refiner",
        "end": END,
    },
)

app = workflow.compile()

import argparse

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="AI Agent for parsing bank statements.")
    parser.add_argument('--target', type=str, required=True, help='The target bank, e.g., "icici".')
    args = parser.parse_args()

    # Initial state for the graph
    initial_state = {
        "target_bank": args.target,
        "current_code": "",
        "error_feedback": "",
        "attempts_left": 3, # max attempts 
    }

    final_state = app.invoke(initial_state)

    if final_state.get("error_feedback") is None:
        print(f"\nSuccessfully generated parser: custom_parsers/{args.target}_parser.py")
    else:
        print(f"\nFailed to generate a working parser for {args.target} after multiple attempts.")